# webserver八股文

1. #### 为什么你的webserver用线程池而不是进程池

   - 资源消耗：线程可以说是轻量级的进程，每个进程都有自己的独立的内存空间、文件描述符、系统资源，线程则不是
   - 共享虚拟内存：线程共享同一进程的内存空间，进程之间的通信更加高效
   - 上下文切换：进程的上下文切换开销比线程大的很多

2. #### 你的webserver的线程数不够了，这个时候来了一个新的http请求会怎么办

   排队等待、拒绝请求、动态扩展线程池

3. #### 阻塞和非阻塞

   阻塞：当一个函数或调用发起后，它会一直等待操作完成，然后才返回结果。

   非阻塞：在非阻塞操作中，当一个函数或调用发起后，它会立即返回，不会等待操作完成。即使操作尚未完成，调用者线程或进程也可以继续执行其他任务，而不必等待

4. #### IO同步异步与并发同步异步的区别

   IO同步：内核向应用程序通知IO就绪，由应用程序去完成IO

   IO异步：内核向应用程序通知IO完成，由内核完成IO

   并发同步：事件按顺序执行，需要等待前面的时间完成，才能开始后面的事件

   并发异步：前面事件的运行结果不影响后面的事件，事件同时完成

6. #### Reactor和Proactor的区别，你的项目怎么实现模拟Proactor

   Reator同步：主线程监听文件描述符上是否有事件发生，发生则通知工作线程。接受连接、读写、逻辑处理都由工作线程完成

   Proactor：将所有的IO操作都交给主线程和内核处理，工作线程只负责业务逻辑

   模拟Proactor：主线程负责IO读写，读写完成之后通知工作线程，工作线程负责接受连接，完成逻辑

7. #### lt和et的区别

   lt:在 LT 模式下，当一个文件描述符（通常是套接字）准备好进行读取或写入时，操作系统会不断地通知应用程序。应用程序如果没有立即处理，下次还会通知。

   et: 在 ET 模式下，操作系统只在文件描述符从未就绪变为就绪状态时发送一次通知。应用程序如果没有立刻处理，则会错过该时间。

   lt 适用于需要持续监视事件状态变化的场景，而 et 适用于需要及时响应事件状态变化的场景
   
8. #### 进程通信方式/线程通信方式

   进程：管道、消息队列、共享内存、信号量、socket

   管道：单向性、fifo、字节流、默认阻塞

   命名管道：持久、双向，在文件系统中有相关的文件
   
   匿名管道：临时、单向、半双工、通常在有公共祖先的进程使用，没有文件系统相关的文件

   线程：锁、条件变量、信号量、消息队列

   #### 可重入

   函数可以被随时中断，它除了使用自己栈上的变量以外不依赖于任何环境

   原子操作、互斥锁、条件变量

9. #### select poll epoll底层实现，时间复杂度

   select数组 1024 lt O(N)

   poll 链表 65535  lt O(N)

   epoll 消息驱动机制 65535 lt/et O(1) 

   epoll 红黑树存储文件描述符、事件注册通知，就绪队列是个双向链表、从就绪队列获取文件描述符

10. #### http协议

   http请求报文：请求行、请求头、空行、请求体

   请求行：方法、uri、http协议版本

   请求头：请求头部包含了关于请求的各种信息（Host、User-agent、accept、content-type

   空行：\r\n

   请求体：要发送的数据，一般是post请求

   http响应报文：状态行、响应头、空行、响应体

   状态行：HTTP协议版本 状态码 状态消息

   响应头：头部字段名: 字段值（server、content-type、content-length、set-cookie）

   空行：\r\n

   响应体：返回给客户端的数据，一般是get方法

   http请求方法：get（指定请求资源）、post（向指定的资源提交数据）、put（向指定的资源位置上传新的内容）、head（请求获取指定资源的响应头部信息）、delete（请求服务器删除指定的资源）、options（请求获取指定资源所支持的通信选项）、trace（回显服务器收到的请求，用于测试和诊断）

   http特点：简单、无状态、可扩展、基于请求和响应

   http各个版本

   http/1.1:支持长连接keep-alive、管道化（客户端可同时发送多个请求）、

   http/2：二进制传输、应用层多路复用、头部压缩、服务器推送

   http/3：基于quic

11. #### 守护进程、僵尸进程

    守护进程：后台运行的进程，与终端无关联，关闭了标准输入输出，守护进程通常用于执行一些系统级别的任务。

    僵尸进程：是已经结束的进程，但其父进程还没有回收其资源（包括进程标识符 PID、内存空间、打开的文件等），导致操作系统资源浪费

12. #### 零拷贝

   是指避免数据在用户态和内核态之间的复制，从而提高数据传输的效率和性能的技术
    sendfile：用于将一个文件的内容直接发送到网络套接字

    splice：两个文件描述符之间的数据直接传输
    
    tee：将一个数据流拷贝到两个不同的管道中

13. #### char*和char[]的区别

    - char\*是一个指针，char\*存储字符数据的地址，可以为nullptr。指向的字符内存可以分配在堆上，也可以分配在栈上，如果分配在堆上，需要程序员动态创建和动态删除
    - char[]是一个静态分配的数组，生命周期和作用域有关
    - char*地址可变，长度可变，char[]静态分配，地址不可变，长度不可变

14. #### sizeof和strlen的区别和结果

    - sizeof是运算符，不是函数，获取数据类型或者变量的字节大小，返回的是编译期间已知的大小
    - strlen是一个函数，用于计算以null结尾的c字符串中的字符数，不包括null字符

15. #### mysql索引类型

    - B+树索引：m阶平衡查找树，只在叶子节点存储数据，减少IO次数

    - 哈希索引：使用哈希函数映射到散列桶

      b+树适用于等值查询、范围查询、排序操作，哈希索引只能适用于等值查询。b+树保证数据有序，b+树存储空间大，维护复杂。哈希插入、删除快。

16. #### 哈希冲突怎么解决

    - 链表法：维护一个链表，当发生冲突时，新的键值对被添加到链表中
    - 开放地址法：线性探测、二次探测、双散列
    - 再哈希：扩大散列表大小，然后再哈希（重新计算所有哈希）
    - 函数函数改进

17. #### 简单介绍一下Docke的工作原理和应用

    docker是一种虚拟化技术，是一种操作系统的抽象，将应用程序和其依赖项打包到一个独立的、轻量级的容器中，容器中包含这些应用程序的所有文件、环境、系统工具和库。

18. #### 对于虚指针有什么了解？为什么要引入虚指针？如果不用虚指针，哪些功能不能够实现？

    - 虚函数表：虚函数表中是一个包含虚函数指针的数组，**每个具有虚函数的类都有自己的虚函数表**，虚函数表存储了虚函数的地址
    
    - 虚函数指针：**每个对象都包含一个指向其类的虚函数表的虚指针**。虚指针使得程序能够在运行时确定要调用的虚函数，而不是在编译时确定。
    
      虚函数和虚指针实现动态绑定


19. #### 虚构造和虚析构

    构造函数不能是虚函数：因为构造函数是用于创建对象的，但是虚函数调用是需要虚指针和虚表。虚指针是放在对象里的，所以虚构造也不行，其次虚构造也没有意义。

    析构函数最好是虚函数：因为子类的资源需要调用子类的析构函数释放，不然会导致资源泄露

20. #### labmda表达式的原理

    [捕获列表]  (参数列表) -> 返回类型 {函数体}

    原理：**编译器将该表达式翻译成一个未命名类的未命名对象**。**该类含有一个重载的函数调用运算符**

21. #### 智能指针有了解吗？详细讲一讲

    unique_ptr：独占型指针

    shared_ptr：共享型指针，控制块里包含共享引用计数和指针（指向内存地址），引用计数为0的时候释放资源

    weak_ptr：弱指针，不增加shared_ptr的引用计数，控制块包含：指针（指向内存地址）、共享引用技术、弱引用技术

    RAII：资源获取即是初始化，简化资源管理、避免资源泄露、调高代码可读性、支持异常安全

    RAII的例子：智能指针、unique_lock等

    RAII使用场景：动态内存分配、文件操作、线程管理、互斥锁和条件变量、数据库连接

22. #### H264 H265 

    - H264：

      **I，P，B**

      I桢；I桢可以通过视频解码算法解压成一个完整的图片

      P桢：需要参考前面的一个I桢或者P桢生成一张完整的图片

      B桢：需要参考前面的I桢或者P桢，并且还要参考后面的I桢或者P桢

      **GOP IDR**

      以I桢开头到下一个I桢被称为一个GOP

      IDR关键帧：立即刷新图像，IDR图像都是I桢图像

      **PTS DTS**

      DTS：解码时间戳，告诉播放器什么时候解码这个数据

      PTS：显示时间戳，告诉播放器什么时候显示这个数据

23. #### UDP做音视频协议怎么实现可靠传输

24. 

