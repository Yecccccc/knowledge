# OS

- 进程、线程、协程定义

  1. 进程是操作系统资源分配和调度的基本单位。一个进程包含一个或者多个线程。每个进程有自己独立的地址空间、内存、文件句柄和其他系统资源
  2. 线程是进程的一个执行单元，是CPU调度的基本单位。一个进程的多个线程共享进程的地址空间、内存、文件句柄和其他系统资源。
  3. 协程是一种用户级别的轻量级线程，由用户代码控制的，而不是操作系统调度。它可以挂起自身并保存上下文，需要时再恢复执行，从而实现多任务处理，协程通常在一个线程内并发执行。

- 进程和线程的区别

  1. 关系/性质/资源：进程是OS调度和分配资源的基本单位，线程是CPU调度基本单位。每一个进程都有一个独立的地址空间。一个进程里面可以有一到多个线程，这些线程共享进程的资源。
  2. 崩溃：一个进程崩溃会导致整个进程都被杀死（进程里面的所有线程也被杀死）。一个线程的崩溃只会影响到该线程，不会影响到其他线程或者进程。
  3. 上下文切换：进程之间切换，需要切换整个进程的上下文环境，耗费较大。线程的上下文切换耗费较小。
  4. 运行：进程和线程都有自己的状态和优先级。线程调度更加高效，因为上下文切换耗费小

- 上下文切换

  1. 流程：挂起——切换上下文——切换——恢复新的上下文——从中断的地方开始执行
  2. 进程上下文：进程内存空间、PCB、文件描述符、信号处理器
  3. 线程上下文：线程栈、寄存器、线程状态等
  4. 协程的上下文：栈、寄存器、协程状态等。

- 进程是如何做到资源隔离的

  1. 独立的地址空间：每个进程都有自己独立的虚拟地址空间
  2. 进程间的通信机制
  3. 
  4. 用户和组的权限控制：不同进程可以属于不同用户或者组，赋予了不同的权限。
  5. 文件系统的隔离：每个进程都有自己的工作目录和根目录。

- 虚拟内存

  1. 虚拟内存的定义与特点

     定义：虚拟内存是操作系统的内存管理技术，将内存和磁盘存储结合使用，从而扩展了系统可用的内存大小

     特点：

     ①可以将物理内存拓展到磁盘空间

     ②可以将不连续的物理内存映射到连续的虚拟地址空间中

     ③实现了内存保护机制。每个进程有独立的虚拟地址空间，进程间无法直接访问对方的内存，保证数据安全

     ④实现了内存共享机制，多个进程可以映射同一块物理内存到各自的虚拟空间

     ⑤可以通过内存映射文件将磁盘上的文件映射到虚拟地址，实现文件的快速访问

  2. 虚拟内存的作用

     ①扩大应用程序内存空间：可以让应用程序看到比实际物理内存更大的内存空间

     ②提高内存利用率，把不常用的数据移动到硬盘

     ③简化内存管理

  3. 虚拟内存的优缺点

     优点：

     ①扩大系统内存容量

     ②允许多个程序同时执行

     ③保护程序的隐私和安全

     ④简化内存管理

     缺点：

     ①性能开销：硬盘到内存

     ②硬盘空间开销

     ③复杂度：虚拟内存实现负责，需要考虑页面置换、页面调度等问题

  4. 虚拟内存的实现

     ①请求调页：程序访问到未映射到物理地址的虚拟地址时，会触发缺页异常，导致操作系统将缺失的页面读入物理内存。

     ②页面置换：当物理内存不足以容纳所有需要的页面时，就需要进行页面置换，把他们移动到磁盘上，以便为新的页面腾出空间。LRU、FIFO、LFU等算法

- 进程间通信方式

  1. 管道：半双工，具有亲缘关系的进程之间进行通信。氛围匿名管道和命名管道。
  2. 共享内存：多个进程共享同一块物理内存，可以高效地进行传输。但是由于没有同步机制，容易导致数据一致性的问题
  3. 信号量：一种计数器，用于进程间的同步和互斥。
  4. 消息队列：进程通过消息传递的方式进行通信，具有一定的同步机制
  5. 套接字：一种全双工的通信方式，可用于不同计算机之间的进程通信
  6. 文件：进程通过读写同一文件进行通信

- 线程间通信方式

  1. 共享内存：线程共享一个地址空间
  2. 信号量：通过使用计数器实现多个线程之间的同步，主要包括两个操作：wait和signal
  3. 互斥量：用于控制对共享资源的访问，加锁和解锁
  4. 条件变量：通过线程的等待和唤醒操作实现同步
  5. 管道
  6. 消息队列
  7. 读写锁：读写锁允许多个线程读资源，但只允许一个线程写资源

- 协程间通信方式

  1. 共享内存

  2. 消息传递

  3. 共享文件

  4. 信号量

     它们共享同一个栈空间，不需要像线程通信那样需要进行线程切换和上下文保存和恢复等操作

- 计算机怎么去管理进程

  创建、撤销、调度、同步、通信

- 内核态下面分哪些模块或者子系统

  1. 进程管理系统
  2. 内存管理系统
  3. I/O管理系统
  4. 文件管理系统

- 线程同步的方式

  1. 互斥锁
  2. 条件变量
  3. 读写锁
  4. 信号量
  5. 屏障
  6. 原子操作

- 中断

  计算机执行程序时，由于发生某些特殊时间，导致当前程序暂停，转而执行相应的中断处理程序的机制。

  硬件中断：是由程序运行过程中产生的，例如除0操作、越界操作等等。

  软件中断：异常，是由程序运行过程中产生的，例如除0操作、越界操作等等

- 死锁

  1. 死锁：两个或者多个进程互相持有对方的资源，但又不释放自己的资源，导致陷入无限循环等待

  2. 必要条件：

     ①互斥条件：进程对所分配资源进行排他性使用

     ②请求和保持：进程保持自己的资源的同时，且一直申请别的资源

     ③不可剥夺：进程已经获得资源在未使用完之前，不可被剥夺

     ④循环等待：多个进程循环等待彼此的资源

  3. 怎么解决死锁：

     ①预防：规定加锁顺序、避免循环等

     ②避免：动态分配资源以避免死锁

     ③检测和解除：周期性检测资源分配情况，判断是否出现死锁，通过撤销进程、回滚、抢占资源等方式解决

- 鸵鸟策略：遇到错误采取忽略或者延后处理的方式

- 银行家算法：预先分配好资源并检测进程申请的安全性，再分配

- 何时会发生内核态和用户态的切换：

  1. 系统调用
  2. 中断和异常
  3. 多任务切换
  4. 虚拟内存管理
  5. 进程间通信
  6. 设备驱动程序

- 内核态和用户态的区别，二者具备的资源

  内核态可以访问系统所有资源

  用户态是指应用程序运行在低特权级下，只能访问部分资源，不能直接访问系统资源和硬件设备

- 多线程中遇到的问题，如何解决，如何debug多线程遇到的问题

  G

- 同步、互斥、阻塞和非阻塞

  1. 同步：多个进程、线程协同工作
  2. 互斥：同步的一种，保证同一时间只有一个进程、线程访问资源
  3. 阻塞：在访问某些资源时，如果该资源已经被占用，则线程被挂起，等待资源的释放，此时线程处于阻塞状态。
  4. 非阻塞：非阻塞：在访问某些资源时，如果该资源已经被占用，则线程不会被挂起，而是立即返回

- 分时操作系统和非分时操作系统的区别

  分时操作系统：多任务系统，将CPU时间划分成若个时间片，每个时间片分配给一个进程使用

  非分时操作系统：同一时刻只有一个程序在运行

- 64位和32位的区别

  处理器的寻址能力、寄存器位数、数据总线宽度

- 并发和并行的区别

  并发：一段时间内，多个任务交替运行

  并行：多个任务在同一时刻同时执行

- 线程的分类

  1. 内核级：操作系统管理，线程切换用操作系统的调度算法
  2. 用户级

- 什么是临界区、临界资源

  临界区：一块访问共享资源的代码区域

  临界资源：被多个线程所访问和共享的资源

- 进程的五个状态，状态间如何转换

  新建->就绪：创建成功准备运行

  就绪->运行：获得了CPU时间并开始执行任务

  运行->就绪：执行完任务

  运行->阻塞：等待外部事件发生（中断）

  阻塞->就绪：进程等待的事件完成

  运行->终止：完成任务或者被强行终止

- 分页与分段的概念，二者有何区别

  1. 分页是将物理内存划分为固定大小的页框，将进程的逻辑地址空间划分为相同大小的页，进程的逻辑地址空间通过页表映射到物理内存的页框中
  2. 分段是将进程的逻辑地址空间划分为若干个逻辑段，每个逻辑段可以看作是一种不同类型的数据或代码。不同的逻辑段具有不同的大小，并且不同的逻辑段可以分配到不同的物理内存位置上
  3. 两者的区别在于，分页是以页为单位来管理内存的，每一页都是相同的大小，而分段则是以段为单位来管理内存的，每个段的大小是不同的，且具有不同的属性和权限。

- 页面置换算法列举几个，讲一下实现原理，请自己实现一个LRU

  LRU、LFU、FIFO

- 什么是IO多路复用，有哪些方式实现IO多路复用

  IO多路复用是一种高效的IO模型，可以同时监视多个文件描述符（socket、文件、管道等）是否有数据可读写，从而避免了多个阻塞的IO操作导致线程或进程被阻塞的问题。

  1. select（遍历）：每次调用select函数都需要重新构造FD_SET集合，随着文件描述符数量的增加，效率逐渐降低等
  2. poll：改进版本，但还是效率低
  3. epoll：事件驱动，避免遍历

- 介绍一下常见的IO模型

  1. 阻塞IO：应用程序发起一个IO操作后，它会一直阻塞等待
  2. 非阻塞IO：在非阻塞IO模型中，应用程序发起一个IO操作后，它不会一直等待，而是立即返回一个错误码
  3. IO复用
  4. 信号驱动IO：应用发起IO操作，注册信号函数，完成IO操作，触发信号函数执行
  5. 异步IO：在异步IO模型中，应用程序发起一个IO操作后，不需要等待IO操作完成，而是可以继续执行其他操作，当IO操作完成时，操作系统会通知应用程序进行处理