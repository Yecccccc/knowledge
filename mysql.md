# mysql数据库

###  mysql表空间结构

表空间由段、区、页、行

1. 行：数据库表中的记录都是按行进行存放的

2. 页：InnoDB的数据是以页为单位进行读写的，默认每个页大小为16kb，最多保证16kb的连续存储空间

3. 区：在表中数据量大的时候，为某个索引分配空间的时候，就不以页分配了，而是以区分配。每个区大小为1mb，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。

4. 段:
    - 索引段：存放b+ tree非叶子结点
    - 数据段：存放b+ tree叶子结点
    - 回滚段：存放回滚数据的区的集合

### InnoDB的compact行格式

InnoDB现在主要是Compact、Dynamic、Compressed三种行格式，后面两种行格式是Compact的改进

Compact行格式包含：记录的额外信息（变长字段长度列表、NULL值列表、记录头信息）、记录的真实数据（row_id、trx_id、roll_ptr、列数据）

1. 变长字段长度列表：变长字段的真实数据占用子结束会按照烈的顺序逆序存放（逆序的目的是位置靠前的记录的真实数据和数据对应的字段长度信息可以在同一个CPU Cache Line，提高Cache命中率）。同时当数据表没有变长字段的时候，行格式里就不会有变长字段长度列表了

2. NULL值列表
允许null值的列，每个列对应一个二进制位（bit），二进制位按照逆序排列，=1：null，=0:不为null，null值列表也不是必须的

3. 记录头信息
delete_mask:表示此条数据是否被删除

next_record:吓一跳记录的位置

record_type:表示当前记录的类型，0表示普通，1表示b+树非叶子节点记录，2表示最小记录，3表示最大记录
4. 记录的真实数据
row_id：如果有主见或者唯一约束列，就没有row_id隐藏字段，如果没有InnDB回味记录添加row_id隐藏字段

trx_id：事物id，表示这个数据是由那个事物生成的

roll_pointer：记录上一个版本的指针
5. mysql规定除了TEXT、BLOBs这种大对象类型外，其他所有列（不包括隐藏列和记录头信息）占用字节长度加起来不超过65535字节
6. 行溢出后，mysql如何处理
发生行溢出后，多的数据就会存到另外的【溢出页】中（部分溢出），Compressed和Dynamic两个格式和Compact十分相似，它们采取的是完全溢出

### 索引

1. 索引分类
**数据结构：b+、hash、full-text**
- 创建的主键索引和二级索引默认使用的是 B+Tree 索引
- B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，磁盘I/O次数不多
**物理存储：聚簇（主键）、二级索引（辅助索引）**
- 主键索引的b+ tree的叶子结点存放的实际数据
- 二级索引的b+ tree的叶子结点存放的是主键
**字段类型：主键、唯一、普通、前缀**
**字段个数：单列、联合**
2. 为什么选择b+树作为索引
   - b+ vs b
    b+ 树只在叶子结点存储数据，而b树的非叶子结点也要存储数据，所以b+ tree的单个结点数据量更小，磁盘io次数小，其次叶子结点之间采用双向链表连接，适合给予范围的顺序查找
   - b+ vs 普通二叉
    b+的搜索复杂度O(logdN), d表示节点允许的最大字结点数为d个
    二叉树是O(logN),二叉树检索到目标数据经历的IO次数比b+ tree多很多
   - b+ vs hash
    hash搜索o(1),但是hash不适合做范围查询
3. 什么时候需要/不需要创建索引？
  什么时候适用索引？
  - 字段有唯一限制
  - 经常使用where条件查询
  - 经常用于group by和order by
  什么时候不需要创建索引？
  - where、group by、order by里用不到的字段
  - 字段中存在大量重复数据
  - 表数据太少
  - 经常更新的字段
4. 有什么优化索引的方法？
   - 前缀索引优化：使用字段的前缀建立索引
    目的：减少索引字段大小
    局限性：order by无法使用、无法把前缀索引作为覆盖索引
   - 覆盖索引优化：避免回表的操作，减少大量io操作
    方法：创建联合索引
   - 主键索引最好自增
    主键索引随机，会插入到现有数据页的随机位置。造成页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。
   - 主键字段不要太大
    主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小
   - 索引not null
   - 防止索引失效
5. 索引失效的场景
   - like 关键字左或者左右模糊匹配
    b+树是按照所有有序排列，根据前缀有序比较
   - 对索引使用函数，对索引进行表达式计算
   - 堆索引隐式类型转换
   - 联合索引非最左匹配
   - where子句中的or
### 事务
1. 事务四个特性
   原子性：一个事物的所有操作要么全部完成、要么全部不完成，innodb通过undo log回滚日志完成
   一致性：事物操作前后，数据满足完整性约束，数据库保持一致性状态，innodb通过持久性+原子性+隔离性保证
   隔离性：允许多个并发事物同时对其数据进行读写和修改，通过mvcc或者锁保证
   持久性：事物处理结束后，对数据修改就是持久的，innodb通过redo log重做日志完成
2. 并发事务引发问题
   - 脏读：一个事物读到了另一个未提交事务修改过的数据
   - 不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况
   - 幻读：在一个事物内多次查询某个符合条件的记录数量，前后两次查询到的记录数量不一样
  严重性排序：脏读 > 不可重复读 > 幻读
3. 事务隔离级别
   - 读未提交：一个事务还未提交，他的变更就能被其他事务看到
   - 读提交：一个事务提交之后，它做的变更才能被其他事务看到，**通过Read View实现**
   - 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**通过ReadView实现**，**innoDB默认隔离级别**
   - 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行，**通过读写锁实现**
  隔离化级别：串行>可重复读>读提交>读未提交
  不同隔离级别，可以发生的问题
  读未提交：脏读、不可重复读、幻读
  读已提交：不可重复读、幻读
  可重复读：幻读
  串行化：无
4. ReadView和MVCC
   - 四个字段（创建ReadView时）
     - m_ids：活跃事务id列表，启动了但还没提交的事务
     - min_trx_id：id最小的事务
     - max_trx_id：创建ReadView时当前数据库中应该给下一个事务的id值
     - creator_trx_id：创建该ReadView事务的事务id
   - 聚簇索引的两个隐藏列
     - trx_id：当事务对某条聚簇索引记录进行改动时，就会把该事务的事务id记录在trx_id
     - roll_pointer:每次对聚簇索引进行改动，都会把旧版本的记录写入undo log回滚日志，roll_pointer指向旧版本记录
   - mvcc
      - 如果trx_id小于ReadView的min_trx_id说明，事务在创建快照前已经提交，所以该版本记录**可见**
      - 如果trx_id大于ReadView的max_trx_id说明，事务在创建快找后才启动，所以该版本记录**不可见**
      - 如果trx_id在min_trx_id和max_trx_id，并且在m_ids列表，表示事务还未提交，该版本记录**不可见**
      - 如果trx_id在min_trx_id和max_trx_id，但不在m_ids列表，表示事务已经提交，该版本记录**可见**
5. 可重复读怎么工作，读提交怎么工作
   可重复读：启动事务时生成一个ReadView，然后整个事务期间都使用这个ReadView
   读提交：每次读取数据时，都会生成一个新的ReadView
6. mysql innoDB的可重复读
   默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象。
   - 快照读select:通过 MVCC 方式解决了幻读
   - 当前读select for upate, update, insert, delete：通过next-key lock（记录锁+间隙锁）方式解决幻读
7. 幻读被完全解决了吗？
   - 事务B insert记录x，后commit，事务A update记录x后（trx_id变成了事务A的事务id），再select出现幻读
   - 事务B先insert记录x，commit，事务A后select for update，出现幻读
### mysql锁
1. mysql有哪些锁
全局锁：整个数据库处于只读（用于全库备份）
表级锁：表锁、元数据锁、
行级锁：
1. 

