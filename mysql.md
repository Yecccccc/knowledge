# mysql数据库

###  mysql表空间结构

表空间由段、区、页、行

1. 行：数据库表中的记录都是按行进行存放的

2. 页：InnoDB的数据是以页为单位进行读写的，默认每个页大小为16kb，最多保证16kb的连续存储空间

3. 区：在表中数据量大的时候，为某个索引分配空间的时候，就不以页分配了，而是以区分配。每个区大小为1mb，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。

4. 段:
    - 索引段：存放b+ tree非叶子结点
    - 数据段：存放b+ tree叶子结点
    - 回滚段：存放回滚数据的区的集合

### InnoDB的compact行格式

InnoDB现在主要是Compact、Dynamic、Compressed三种行格式，后面两种行格式是Compact的改进

Compact行格式包含：记录的额外信息（变长字段长度列表、NULL值列表、记录头信息）、记录的真实数据（row_id、trx_id、roll_ptr、列数据）

1. 变长字段长度列表：变长字段的真实数据占用子结束会按照烈的顺序逆序存放（逆序的目的是位置靠前的记录的真实数据和数据对应的字段长度信息可以在同一个CPU Cache Line，提高Cache命中率）。同时当数据表没有变长字段的时候，行格式里就不会有变长字段长度列表了

2. NULL值列表
允许null值的列，每个列对应一个二进制位（bit），二进制位按照逆序排列，=1：null，=0:不为null，null值列表也不是必须的

3. 记录头信息
delete_mask:表示此条数据是否被删除

next_record:吓一跳记录的位置

record_type:表示当前记录的类型，0表示普通，1表示b+树非叶子节点记录，2表示最小记录，3表示最大记录

4. 记录的真实数据
row_id：如果有主见或者唯一约束列，就没有row_id隐藏字段，如果没有InnDB回味记录添加row_id隐藏字段

trx_id：事物id，表示这个数据是由那个事物生成的

roll_pointer：记录上一个版本的指针

5. mysql规定除了TEXT、BLOBs这种大对象类型外，其他所有列（不包括隐藏列和记录头信息）占用字节长度加起来不超过65535字节

7. 行溢出后，mysql如何处理
发生行溢出后，多的数据就会存到另外的【溢出页】中（部分溢出），Compressed和Dynamic两个格式和Compact十分相似，它们采取的是完全溢出

### 索引

1. 索引分类
**数据结构：b+、hash、full-text**
- 创建的主键索引和二级索引默认使用的是 B+Tree 索引
- B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，磁盘I/O次数不多
**物理存储：聚簇（主键）、二级索引（辅助索引）**
- 主键索引的b+ tree的叶子结点存放的实际数据
- 二级索引的b+ tree的叶子结点存放的是主键
**字段类型：主键、唯一、普通、前缀**
**字段个数：单列、联合**
2. 为什么选择b+树作为索引
   - b+ vs b
    b+ 树只在叶子结点存储数据，而b树的非叶子结点也要存储数据，所以b+ tree的单个结点数据量更小，磁盘io次数小，其次叶子结点之间采用双向链表连接，适合给予范围的顺序查找
   - b+ vs 普通二叉
    b+的搜索复杂度O(logdN), d表示节点允许的最大字结点数为d个
    二叉树是O(logN),二叉树检索到目标数据经历的IO次数比b+ tree多很多
   - b+ vs hash
    hash搜索o(1),但是hash不适合做范围查询
3. 什么时候需要/不需要创建索引？
  什么时候适用索引？
  - 字段有唯一限制
  - 经常使用where条件查询
  - 经常用于group by和order by
  什么时候不需要创建索引？
  - where、group by、order by里用不到的字段
  - 字段中存在大量重复数据
  - 表数据太少
  - 经常更新的字段
4. 有什么优化索引的方法？
   - 前缀索引优化：使用字段的前缀建立索引
    目的：减少索引字段大小
    局限性：order by无法使用、无法把前缀索引作为覆盖索引
   - 覆盖索引优化：避免回表的操作，减少大量io操作
    方法：创建联合索引
   - 主键索引最好自增
    主键索引随机，会插入到现有数据页的随机位置。造成页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。
   - 主键字段不要太大
    主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小
   - 索引not null
   - 防止索引失效
5. 索引失效的场景
   - like 关键字左或者左右模糊匹配
    b+树是按照所有有序排列，根据前缀有序比较
   - 对索引使用函数，对索引进行表达式计算
   - 堆索引隐式类型转换
   - 联合索引非最左匹配
   - where子句中的or
### 事务
1. 事务四个特性
   原子性：一个事物的所有操作要么全部完成、要么全部不完成，innodb通过undo log回滚日志完成
   一致性：事物操作前后，数据满足完整性约束，数据库保持一致性状态，innodb通过持久性+原子性+隔离性保证
   隔离性：允许多个并发事物同时对其数据进行读写和修改，通过mvcc或者锁保证
   持久性：事物处理结束后，对数据修改就是持久的，innodb通过redo log重做日志完成
2. 并发事务引发问题
   - 脏读：一个事物读到了另一个未提交事务修改过的数据
   - 不可重复读：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况
   - 幻读：在一个事物内多次查询某个符合条件的记录数量，前后两次查询到的记录数量不一样
  严重性排序：脏读 > 不可重复读 > 幻读
3. 事务隔离级别
   - 读未提交：一个事务还未提交，他的变更就能被其他事务看到
   - 读提交：一个事务提交之后，它做的变更才能被其他事务看到，**通过Read View实现**
   - 可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**通过ReadView实现**，**innoDB默认隔离级别**
   - 串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行，**通过读写锁实现**
  隔离化级别：串行>可重复读>读提交>读未提交
  不同隔离级别，可以发生的问题
  读未提交：脏读、不可重复读、幻读
  读已提交：不可重复读、幻读
  可重复读：幻读
  串行化：无
4. ReadView和MVCC
   - 四个字段（创建ReadView时）
     - m_ids：活跃事务id列表，启动了但还没提交的事务
     - min_trx_id：id最小的事务
     - max_trx_id：创建ReadView时当前数据库中应该给下一个事务的id值
     - creator_trx_id：创建该ReadView事务的事务id
   - 聚簇索引的两个隐藏列
     - trx_id：当事务对某条聚簇索引记录进行改动时，就会把该事务的事务id记录在trx_id
     - roll_pointer:每次对聚簇索引进行改动，都会把旧版本的记录写入undo log回滚日志，roll_pointer指向旧版本记录
   - mvcc
      - 如果trx_id小于ReadView的min_trx_id说明，事务在创建快照前已经提交，所以该版本记录**可见**
      - 如果trx_id大于ReadView的max_trx_id说明，事务在创建快照后才启动，所以该版本记录**不可见**
      - 如果trx_id在min_trx_id和max_trx_id，并且在m_ids列表，表示事务还未提交，该版本记录**不可见**
      - 如果trx_id在min_trx_id和max_trx_id，但不在m_ids列表，表示事务已经提交，该版本记录**可见**
5. 可重复读怎么工作，读提交怎么工作
   可重复读：启动事务时生成一个ReadView，然后整个事务期间都使用这个ReadView
   读提交：每次读取数据时，都会生成一个新的ReadView
6. mysql innoDB的可重复读
   默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象。
   - 快照读select:通过 MVCC 方式解决了幻读
   - 当前读select for upate, update, insert, delete：通过next-key lock（记录锁+间隙锁）方式解决幻读
7. 幻读被完全解决了吗？
   - 事务B insert记录x，后commit，事务A update记录x后（trx_id变成了事务A的事务id），再select出现幻读
   - 事务B先insert记录x，commit，事务A后select for update，出现幻读
### mysql锁
1. mysql有哪些锁
全局锁：整个数据库处于只读（用于全库备份）
表级锁：
   - 表锁
   - 元数据锁(MDL):不需要显式使用：对一张表CRUD，加的是MDL读锁，对一张表变更，加的是MDL写锁。MDL锁一直到事务提交后才释放，并且写锁的优先级高于读锁
   - 意向锁：在网表里的记录加上共享/独占锁之前，会先加上意向共享/独占锁。意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。意向锁的目的是为了快速判断表里是否有记录被加锁。**意向锁的目的是为了快速判断表里是否有记录被加锁**
   - AUTO-INC锁：AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放
行级锁：
   共享锁：读读共享、读写互斥
   独占锁：读读互斥，读写互斥
   - Record Lock记录锁：仅仅把一条记录锁上。
   - Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身。间隙锁之间是兼容的，因为间隙锁的目的是防止插入幻影记录而提出的。
   - Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身
   - 插入意向锁：一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁。插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种特殊的间隙锁，属于行级别锁
2. 死锁
   - 死锁的四个条件：互斥、持有且等待、不可剥夺、循环等待
   - 解决死锁的办法：超时时间、开启主动死锁检测
### mysql日志
1. 三种日志
   undo log和redo log是innodb引擎生成，binlog由server层生成
   - undo log 回滚日志，实现原子性，用于事务回滚（事务崩溃，可以回滚）和mvcc（页面中的记录）
   - redo log 重做日志：实现持久性，用于掉电等故障恢复（断点时更新，innodb会先更新内存，再将修改用redo log记录）
     WAL（Write-Ahead Logging）：mysql的写不是立刻写到磁盘上，先写日志，合适的时候在写磁盘
   - binlog 归档日志：用于数据备份和主从复制
3. buffer pool:缓存技术提高数据库的读写性能，innodb为buffer pool申请一片连续的内存空间，然后按照16kb划分出一个个页面
   - 读取数据时，如果数据存在于buffer pool，客户端直接读取buffer pool的数据，否则再去磁盘读写
   - 修改数据时，如果数据存在于buffer pool，直接修改buffer pool的数据所在页，然后设置为脏页，为了减少io，不会立刻写入磁盘，后续由后台线程选择合适的时机将脏页写入磁盘
   - undo页：开启事务后，innodb更新记录前，首先要记录相应的undo log，如果是更新操作，需要把被更新的列的旧值记下来，生成一条undo log，unlog log会写入buffer pool的undo页
4. undo log和redo log的区别
   - redo log记录此次事务**完成后**的数据状态，记录的是更新之后的值
   - undo log记录此次事务**开始前**的数据状态，记录的是更新之前的值
   - 事务提交之前发生崩溃，重启后会通过undo log回滚事务，事务提交之后发生崩溃，重启后会通过redo log恢复事务
   - 通过redo log和wal技术，innodb保证数据库发生异常重启后，之前提交的记录不会丢失，这个能力称为crash-safe。redo log保证了四大特性的持久性
5. binlog，binlog与redo log的区别
一开始mysql没有innodb引擎，mysql使用的是myisam，但是myisam没有crash-safe能力，binlog只能用于归档
区别：
    - 使用对象不同：binlog是server层的日志，所有存储引擎都可以使用。redo log是innodb存储引擎实现的日志
    - 文件格式不同：
      **binlog有三种格式类型，分别是statement（默认）、row、mixed**
      statement：每一条修改数据的sql都会被记录到binlog里，主从复制里再根据这些sql语句重现
      row：记录行数据最终被修改成什么
      mixed：包含statement和row模式，根据不同情况使用不同模式
      **redo log是物理日志，记录在某个数据页做了什么修改**
   -  写入方式不同：binlog是追加写（全量日志），redo log是循环写（写满重新写，保存未被刷入磁盘的脏页日志）
   -  用途不同：binlog用于备份恢复、主从复制。redo log用于掉电等故障恢复（整个数据库被删除，只能使用binlog，因为binlog存储的是全量日志）
6. 主从复制怎么实现
   异步，3个阶段：
   - 写入binlog：主库写binlog日志，提交事物，更新本地存储数据
   - 同步binlog：把binlog复制到所有从库上，每个从库把binlog写到暂存日志中
   - 回放binlog：回放binlog，并更新存储引擎中的数据
   从库越多，主库也要创建同样多的log dump线程处理复制的请求，对主库资源消耗高，同时受限于主库网络带宽
8. mysql主从复制还有哪些模型
   - 同步复制：提交事物的线程需要等待从库复制成功才响应。性能很差，可用性差（任何一个库出问题，都会影响业务）
   - 异步复制（默认）：主库提交食物的线程并不会等待binlog同步到各从库，就返回客户端。主库宕机，数据就会丢失。
   - 半同步复制：事务不用等待所有从库复制成功响应，只要一部分复制成功响应回来就行
10. 两阶段提交
问题：
    - redo log刷入磁盘，mysql宕机，binlog没有写入，导致主库是新的，从库是旧的
    - binlog刷入磁盘，mysql宕机，redo log没有写入，导致从库是新的，主库是旧的
两阶段提交：（内部XA事务）
    - prepare阶段：将XID（内部事务的ID）写入redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化道磁盘
    - commit阶段：将XID写入binlog然后将binlog持久化到磁盘，接着调用引擎的提交事物接口，将redo log设置为commit，此时该状态并不需要持久化到磁盘，只需要write到文件系统的page cache中就够了，因为只要binlog些磁盘成功，redo log是prepare一样认为事务执行成功。
### buffer pool
1. 为什么有buffer pool，buffer pool有多大，缓存什么？
   - 有了buffer pool后，对于读数据，如果数据存在于buffer pool中，客户会直接访问buffer pool，不需要io。修改数据，直接修改buffer pool所在页面为脏页，最后由后台线程将脏页写入磁盘
   - buffer pool默认配置是128mb
   - buffer pool缓存若干个16kb的页。包括索引页、数据页、插入缓存、undo页、自适应哈希索引、锁信息
   - innodb为每个缓存页创建了控制块，控制块信息包括：缓存页的表空间、页号、缓存页地址、链表结点等。
   - 查询一条记录时，会缓存这个页
2. 如何管理buffer pool
   - 管理空白页，使用free链表
   - 管理脏页：使用Flush链表
提高缓存命中率：lru算法
3. lru算法问题：
   - 预读失效：mysql加载数据页的同时，会把相邻的数据页一并还在，提前祝被加载的数据页没有被访问
   解决办法：将lru划分2个区域，old区域与young区域。预读放到old区域只有被命中了才放到young区域，young区域被淘汰的页面，也会先进入old区域
    - buffer污染：某一个sql语句扫描大量数据（比如不使用索引）导致大量数据淘汰
   解决办法：
    mysql进入到young区域增加一个停留在old区域的时间判断
    如果后续访问时间与第一次访问时间在某个时间间隔内，该缓存页不会移动到young区域头部
    如果不在某个时间间隔内，移动到young区域头部
