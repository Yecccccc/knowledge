# 1.C++语言基础

#### 1.1 简述CPP语言特点

1. CPP在C的基础上引入了面向对象机制，也兼容C语言
2. CPP有三大特性：封装、继承、多态
3. CPP代码生成质量高、运行效率高。仅比汇编慢10%-20%
4. C++可复用性高，引入模板类，引入STL
5. C++更安全，比如类型转换
6. C++不断完善版本。C++11

#### 1.1 Tips

##### 四种类型转换：

static_cast:可以实现C++中内置基本数据类型之间的相互转换，enum、struct、 int、char、float等。它不能进行无关类型(如非基类和子类)指针之间的转换

const_cast操作不能在不同的种类间转换。相反，它仅仅把一个它作用的表达式转换成常量

reinterpret_cast：类似C风格的强制转换同样的能力

dynamic_cast：和其他三种不同，它是运行时处理的，还要进行类别检查。不能用于基本数据类型的强制转换。成功返回类的指针或者引用，失败返回NULL。要求：基类必须有虚函数，不然编译不过。dynamic_cast具有类型检查的功能。

##### 智能指针

智能指针用于解决内存泄漏和悬挂指针问题

unique_ptr：独占型。一个unique_ptr可以指向一个对象，不允许多个指针共享一个对象。使用unique_ptr转移对象用std::move()函数

shared_ptr：共享型。可以有多个shared_ptr指向同一个对象。它使用引用计数来跟踪有多少个shared_ptr指向同一个对象。当引用计数为0时，对象被自动销毁。

weak_ptr：weak_ptr是shared_ptr的一种扩展，它可以用于解决shared_ptr循环引用的问题。weak_ptr指向一个shared_ptr所管理的对象，但是并不增加引用计数。weak_ptr可以使用lock()函数获取一个指向所管理对象的shared_ptr，从而访问对象。如果对象已经被销毁，则lock()函数返回一个空shared_ptr。

##### nullptr和NULL（nullptr更安全）

类型不同：NULL被定义为0，nullptr类型是nullptr_t是一个特殊的空指针类型。类型检查严格的场景下，可以避免类型转换错误。

nullptr和NULL可以相互转换

##### lambda匿名函数

[capture list] (parameter list) -> return type { function body }

临时的、简短的，只使用一次的

caputre list: [=]按值捕获、[&]按引用捕获、[name]按名称捕获

##### 右值引用

是左值引用的拓展，两个作用：

1.移动语义

移动语义可以提高程序的效率，避免因为复制对象而带来的额外开销。移动语义是通过将资源的所有权从一个对象转移到另一个对象来实现的

2.完美转发

右值引用还可以用于实现完美转发。完美转发是指在函数调用时，将参数按照原始类型和值分类，然后将它们转发给其他函数

#### 1.2 C++ struct class区别

1. struct一般用于描述一个数据结构的集合，class对一个对象数据的封装
2. struct默认访问权限Public，class默认private
3. struct默认共有继承，class是私有
4. class可以定义模板参数，struct不可以
5. C++和C的struct区别如下

|          |                C                 |           C++            |
| :------: | :------------------------------: | :----------------------: |
| 成员函数 |              不能有              |           可以           |
| 静态成员 |              不能有              |           可以           |
| 访问控制 |       默认public，不能修改       | public/private/protected |
| 继承关系 |            不可以继承            | 可从类或者其他结构体继承 |
|  初始化  |      不能直接初始化数据成员      |           可以           |
|   使用   | C需要sturct关键字和typedef取别名 |        省略关键字        |

#### 1.3 include圆括号和尖括号区别

1. <>系统文件,""自定义文件
2. 编译器预处理阶段查找头文件路径不一样，<>：编译器设置的头文件路径-->系统变量。“”：当前头文件目录-->编译器设置的头文件路径-->系统变量

#### 1.4 导入C函数的关键字是什么，C和C++编译时有什么不同

1. 导入C函数的关键字为extern，表达形式为"'extern C"，能让C++正确调用C语言代码
2. 编译区别：C++支持函数重载，在编译时候会把参数类型加到编译后代码里，C不会

#### 1.5 C++代码到可执行二进制的过程

1. 预编译：展开所有宏定义、处理所有条件预编译指令、处理#include预编译指令、过滤注释、添加行号和文件名标识

2. 编译：词法分析（代码->记号）、语法分析（记号->语法树）、语义分析(表达式意义)、代码优化、目标代码生成、目标代码优化

3. 汇编：汇编语言变为机器语言

4. 链接：将不同源文件产生的目标文件链接，形成可执行程序

   **静态链接**：在链接的时候已经把要调用的函数或者过程链接到了可执行文件中，把静态库删除也不会影响可执行程序的执行；静态库在win下为.lib，在linux是.a

   **动态链接**：链接的时候没有把调用函数代码链接进去，而是在执行过程中找要执行的函数，生成的可执行文件只包含函数的重定位信息。动态库win下为.dll，linux为.so

#### 1.6 static关键字

2. 静态函数、静态变量：只能在本源文件使用
3. 类静态成员、静态成员函数：所有类对象共享同一个静态成员/成员函数和其存储空间，是类的一部分
4. 静态全局变量、静态局部变量都在静态存储区，直到程序结束才会回收内存。类静态成员变量在静态存储区，当超出类作用域时回收内存。

#### 1.7 说说什么是函数指针，如何定义函数指针，有什么使用场景‘

定义：只想函数的指针变量。

```C++
int func(int a);
int (*f) (int a);
f = &func;
```

使用场景回调，函数当形参

#### 1.8 内联函数和宏函数

宏定义不是函数，单纯的替换，没有入栈过程。内联函数是函数体简单的频繁调用的函数，不能包含复杂控制语句while switch，内联函数不能自己调用自己

#### 1.9 new和malloc区别

1. new是关键字、malloc是函数。new先分配内存，在调用构造函数，释放调用析构函数，malloc则不是。
2. malloc需要类型强制转换和指定内存大小
3. new可以被重载，malloc不行。new更安全，new失败抛出异常，malloc返回NULL

#### 1.10 const和define

const和define都可以定义常量。const生效于编译阶段，define生效于预编译阶段。const定义的常量需要放入内存，define是直接替换。const带类型

#### 1.11 指针函数和函数指针

指针函数（返回指针的函数）本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数

#### 1.12 const用法

```C++
const int a;     //指的是a是一个常量，不允许修改。
const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
int const *a;    //同const int *a;
int *const a;    //a指针所指向的内存地址不变，即a不变
const int *const a;   //都不变，即（*a）不变，a也不变
```

#### 1.13 内联函数和普通函数

内联函数调用没有开销，内联函数不需要寻址，内联函数要求代码简单，不包含复杂控制

#### 1.14 C++的传值方式

值传递：在函数体创建一个新的变量

引用传递：影响参数内存中存储的值

指针传递：指针指向不变的前提下，影响指针指向的内存区域的值
