# C++

- C++和C语言Java语言的区别，面向对象和面向过程的区别

  1. C语言是面向过程的语言，面向过程更像是计算机顺序处理指令那一套
  2. C++可以理解为C + OOP（面向对象编程）+ 模板化 + STL库。面向对象编程是一种高级编程方式，它是以我们人类的思考方式，方法和数据依托于对象存在，从而达到更好地模拟现实世界和代码复用，更有利于大规模项目
  3. C++和JAVA的区别，C++是编译型语言，JAVA是解释型语言。C++的源码在跨系统方面更好，C++的运行效率也更高，C++更接近底层。

- 封装、继承、多态

  封装是指对象的成员变量和成员函数作为一个整体处理

  继承是指在已有的类上创建新类的过程

  多态是面向对象编程中的一个概念，指的是同一个操作作用于不同的对象时，可以产生不同的结果。

- 编译时多态、运行时多态

  编译时多态又叫静态多态：重载函数、模板类编程

  运行时动态又叫动态多态：

  ​		两个条件：①派生类重写基类的虚函数②通过基类指针或者引用调用派生类的虚函数

  ​		结果：调用的是派生类覆盖后的虚函数

- 静态成员、类的静态成员、如何复制

  用static关键字定义静态成员/函数

  未初始化静态数据成员定义在bss段，初始化静态成员定义在DATA段

​		类外：

​			全局静态变量/函数：整个源文件可见，离开这个源文件不可见

​			局部静态变量/函数：局部可见，离开这个源文件不可见

​		类静态成员/函数：

​			类的静态成员/函数属于整个类，不属于某个对象

- 继承中，构造函数的执行顺序

  1. 先基类，后派生类
  2. 初始化基类的时候，有多个继承，按照继承列表顺序构造

- 如何避免外部实例化这个类的对象？

  构造函数定义为private、定义纯虚函数成为抽象类、使用C++11的 = delete方法禁用构造函数

- C++一个空类占多少字节

  1个字节，C++有内存对齐，按照类的第一个成员变量的大小整数倍对齐

- 什么是空白基类最优化

  将基类定义为空白，利用这个规定，可以省去那一个字节，可以有效减少内存的使用

- C++一个空类默认有哪几个函数，请写出函数定义

  默认构造函数、默认析构函数、默认拷贝构造函数、默认移动构造函数、默认移动拷贝构造函数、默认重载赋值运算符、默认重载移动赋值函数、默认取地址函数

- 介绍一下内存分区

  从上到下依次为：

  内核空间、命令行参数、环境变量、栈区、共享区、堆区、数据段、bss段、代码段

- 堆区和栈区的区别

  1. 开辟和释放：堆区的开辟由new和malloc开辟，释放由delete和free释放。栈区的开辟和释放由程序控制，一般进入某个函数，其局部变量会入栈，离开函数则出栈。
  2. 申请速度：栈区是线性、连续结构，堆区是非线性、离散结构，栈区速度快于堆区
  3. 如何存储：栈区就是栈这个数据结构，堆区是类似于链表

- 什么是内存碎片

  内存碎片是指内存多次分配和释放后，内存被分成了多块、不连续、小空间。

  外部碎片：内存分配和释放操作中，由于多次的分配和释放导致内存区域被划分成了许多不连续、小而零散的空间。

  内部碎片：指在内存分配时，由于程序申请的内存空间比实际需要的要大，而申请到的内存中剩余的空间无法再被利用。

- 智能指针

  raii：资源获取即初始化

  unique_ptr：独占性指针，独占资源

  shared_ptr：共享形指针，共享资源。有一个ref计数器，记录几个shared_ptr共享这个资源，计数器等于0释放

  weak_ptr：用于解决shared_ptr的循环引用问题，有一个弱引用计数，弱引用计数记录weak_ptr的个数。
  
- shared_ptr是线程安全的么

  是，使用了引用计数来跟踪生命周期，引用计数自增和自减是原子操作。

- 类型转换的方法

  C++11提供了四种类型转换：

  static_cast：可以用于基本类型的转换，可以用于基类与派生类的转换，用于基类转派生类的时候是不安全的。

  const_cast：把const变成可修改的volite

  dynamic_cast：派生类和基类的转换，类型检查，安全

  reinterpret_cast：C语言风格的强制类型转换

- C++异常，列举一下异常，构造函数中可以有异常吗，析构函数中可以有异常吗

  std::runtime_error：运行时错误：数组越界、除数为0等

  std::logic_error：逻辑错误：无效参数、非法状态等

  std::bad_alloc：内存分配失败

  构造函数可以有异常（如内存分配失败）：如果构造函数异常，则析构函数不会被调用

  析构函数可以有异常：异常往往被忽略，程序终止运行。

- 什么时候栈溢出、什么时候堆溢出

  栈溢出：递归过多、局部变量过多

  堆溢出：内存泄露、申请空间太大

- 函数的传参方式

  值传递、引用传递、指针传递、const传递、默认参数、变长模板参数

  ```c++
  // 最后要调用这个，用于递归终止
  template <typename T>
  T sum(T t) {
      return t;
  }
  // 变长参数
  template <typename T, typename... Args>
  T sum(T t, Args... args) {
      return t + sum(args...);
  }
  
  int main() {
      std::cout << sum(1, 2, 3, 4, 5) << std::endl; // 输出15
      std::cout << sum(1.0, 2.0, 3.0) << std::endl; // 输出6.0
      return 0;
  }
  ```

  

- 父类析构函数要设置为虚函数吗，为什么要这样做

  需要，如果父类指针指向了子类对象的话，如果不用虚析构形成多态，会导致内存泄露

- 虚函数是如何实现的

  1. 虚函数的实现方式是虚函数表和虚函数指针。
  2. 每个包含虚函数的类都有一个虚函数表（数组），记录指向虚函数的指针（虚函数地址）。当一个对象被创建时，为其分配一块内存存储虚函数表，并将虚函数表的指针保存在对象头部（虚指针）。
  3. 多继承就有多个虚指针指向多个虚表

- 什么是菱形继承，如何解决

  B, C继承A。D继承B,C。那么A的资源会在D里面出现两次，造成内存浪费。

  解决办法：B, C虚继承A

- this指针是什么，有什么用，struct里面有this指针吗？struct和class最本质的区别、this指针存储在哪

  1. 是什么？C++里，每个非静态成员函数都有一个隐含的指向当前对象的指针，该指针被称为this指针
  2. 用处：解决成员变量和形参同名的问题
  3. struct和class完全一致，只是访问权限不同，class默认Private，struct默认Public。此外struct常被用于数据类
  4. this指针存储在对象的内存空间中，当对象调用成员函数时，把this指针传进去

- typedef、define、const、什么时候const无法代替define

  1. #define是宏定义，在预编译阶段处理。#define A B;告诉编译器看到了A就把他理解为B。typedef和const都是操作符
  2. typedef是起别名的作用，const是定义常量的作用
  3. 宏定义、编译器常量无法用const替代define

- 独占型智能指针如何赋值

  ```C++
  // 空指针
  std::unique_ptr<int> p(new int(10));
  p = nullptr; // p变成空指针，原来的指针将会释放它所拥有的资源
  
  // 用一个独占型智能指针赋值给另一个独占型智能指针, unique不能被复制，需要用move
  std::unique_ptr<int> p1(new int(10));
  std::unique_ptr<int> p2(new int(20));
  p1 = std::move(p2); // p1接管p2的资源，p2变成空指针
  
  // 用一个原始指针赋值给独占型智能指针
  std::unique_ptr<int> p(new int(10));
  int* q = new int(20);
  p.reset(q); // p接管q的资源，原来的指针将会释放它所拥有的资源
  ```

- lambda表达式如何接收外部传入的参数

  1. 值捕获（`[=]`）：以值的方式捕获所有外部变量。
  2. 引用捕获（`[&]`）：以引用的方式捕获所有外部变量。
  3. 指定变量名捕获（`[x]`）：以值的方式捕获变量`x`。
  4. 指定变量名引用捕获（`[&x]`）：以引用的方式捕获变量`x`。
  5. 指定变量名和捕获方式捕获（`[x&]`或`[&x]`）：以指定的方式捕获变量`x`。

  ```C++
  [capture list] (parameter list) -> return type { function body }
  ```

- C++ 访问map的value方法

  1. map[key]
  2. map.at(key)
  3. 用迭代器的second访问

- 迭代器的begin, cbegin, rbegin

  begin返回开始的普通迭代器

  cbegin返回开始的const迭代器

  rbegin返回最后的迭代器

- vector的resize和reserve有何区别

  resize调整vector动态数组中存放元素的size大小

  reserve调整vector动态数组的容量capacity

- vector如何清空所占内存，如何清空size，如何清空capacity

  1. 清除元素，使用clear()
  2. 清空内存，需要定义一个空的vector，然后用swap函数交换
  3. 清空size，resize(0)
  4. 清空capacity和清空内存一样

- vector扩容机制

  如果vector的capacity大小不足以容纳新元素，则自动分配一段更大的连续空间来存储新元素

- set和map的区别

  1. set存储单个，map存储key-value
  2. set和map都采用红黑树

- map中[]跟insert区别

  []可以直接用key索引，如果不存在则会创建新元素。可以用于查找也可以用于创建

  insert直接插入，如果key已经存在，则不进行任何操作。返回值是指向key的迭代器

- 红黑树的原理，查询复杂度（平均， 最差）

  红黑树是一个自平衡的二叉查找树，最坏O(log N)，平均是 O(log N)，因为是平衡的

- C++多线程如何实现，调的哪个库，多线程如何保证线程安全

  库：#include<thread>

  保证安全：

  1. 互斥锁 std::mutex
  2. 条件变量：std::condition_variable
  3. 原子操作：std::atomic等等

- 代码由源代码到可执行文件的转化过程

  源码——预处理（展开宏，去除注释）——词法分析（分隔记号）——语法分析（语法树）——语义分析（判断表达式是否合理）——目标代码生成——目标代码优化——链接

- 动态链接和静态链接

  静态链接：静态链接将在编译时将所有需要的库函数和代码复制到可执行文件中。程序运行的时候将不再需要静态库。

  动态链接：程序在运行的时候才去链接动态库的代码，多个程序共享使用库的代码。

  静态库的链接：（编译时链接的）

  1. 使用gcc -c和-o选项将文件编译为目标文件
  2. 使用ar命令打包成为静态库
  3. gcc编译mian.c 加上-L选项，-l指定库名

  动态库的链接：（隐式和显式）
  1. gcc -fpic -shared
  2. 隐式：和静态链接方式一样，加上-L选项，通过-l指定库名（在编译时，链接器会将动态库的名称和路径记录在可执行文件中，以便在程序运行时能够找到并加载动态库）
  3. 显式：在程序里通过dlopen()打开动态库和dlsym()手动提取符号表（在程序运行时，使用动态链接库加载函数显式加载动态库，并使用符号获取函数地址（如dlsym()），然后通过函数指针调用动态库中的函数）。运行时链接类似于打开文件，编译时不需要额外指定位置。

- 大端、小端、网络字节序、主机字节序

  大端：高位字节低地址，低位字节高地址

  小端：高位字节高地址，低位字节低地址

  网络字节序：大端

  主机字节序：有的小端，有的大端。

  小端与小端主机通信：在网络中会被取反两次，所以不影响
  
- new和malloc的区别，operator new和new operator
  
  1. new是C++关键字，返回指针，自动调用对象的构造函数。失败抛出std::bad_alloc异常，与delete配套使用。new关键字底层通过operator new函数动态申请内存，operator new可以被重载，实现不同内存的分配行为。
  2. malloc是标准库函数，用于分配指定大小的内存块，返回指向内存块的指针，需要强转。不会调用构造函数。失败返回NULL，与free配套使用。
  
- 内存对齐

  1. 内存对齐：把各个类型数据按照一定的规则在空间上排列，而不是一个一个顺序排列，内存对齐是首地址对齐，而不是变量大小对齐

  2. 主要原因：
  
  有些CPU只能在特定地址访问数据，对齐的内存，移植性更好
  
    CPU每次寻址都需要消费时候，CPU以字长为单位访问，所以数据结构应该对齐，加快访问速率

  3. 内存系数：32位平台对齐系数为4，64位平台对齐系数为8



- 
  
  
  

