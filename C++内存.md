## 2 C++内存

#### 2.1 堆和栈的区别

1. 堆栈空间分配不同。栈由操作系统自动分配释放，存放函数的参数值，局部变量。堆由程序员分配释放
2. 堆栈缓存方式不同。栈使用一级缓存，它们通常是被调用时处于存储空间里，调用完立即释放。堆是在二级缓存中，速度稍慢
3. 数据结构不同

#### 2.2 C++的内存管理

- 内存分配方式：包括堆、栈、自由存储区、全局/静态存储区和常量存储区

  栈：函数内局部变量在堆上创建，执行结束时被释放

  堆：new分配的内存块

  自由存储区：malloc等分配的内存块，和堆十分相似，但是用free结束生命周期

  全局/静态存储区：全局变量和静态变量分配到同一块内存中

  常量存储区：存放常量，不允许被修改

- 内存泄漏及解决办法

  内存申请了，使用完毕后没有释放掉：new和malloc申请资源使用后，没有delete和free。子类继承父类析构函数不是虚函数。windows句柄资源使用后没有释放

#### 2.4 程序的section，作用是什么，程序启动过程

**程序section：**

从低地址到高地址，程序由代码段、数据段、BSS段、堆、共享区、栈组成

1. 数据段：存放程序已经初始化的全局变量和静态变量的内存区域
2. 代码段：存放程序执行代码的一块内存区域。制度，代码段的头部还包含一些只读的常数变量
3. BSS段：存放程序中未初始化的全局变量和静态变量的一块内存区域
4. 堆区：动态申请内存用。堆从低地址向高地址增长
5. 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续空间。
6. 共享区:位于堆和栈之间
7. 常量存储区：存放常量，不允许修改

**程序启动过程**：

1. 操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
3. 加载器针对该程序的每一个动态链接库调用LoadLibrary （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。 （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。 （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3 （4）调用该动态链接库的初始化函数
4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。
5. 进入应用程序入口点函数开始执行。

#### 2.3 内存对齐

内存对齐应用于三种数据类型中：**struct/class/union**

struct/class/union内存对齐原则有四个：

1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。
4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

**什么是内存对齐？**

那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**编译器为结构体的每个成员按其自然边界（alignment）分配空间。**各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。

为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，**即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除**，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。

比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

**为什么需要内存对齐？**

需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。

而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。

各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。